# =============================================
# Git Global Configuration File
#
# This is an optimized Git configuration file.
# =============================================

[user]
    # Enforce explicit configuration to prevent committing as system user
    useConfigOnly = true

    # Default identity (Overridden by includeIf for specific directories)
    name = Foo
    email = Foo@individual.com
    signingkey = AAAAAAAAAAAAAAAA

[core]
    # CACHE & PERFORMANCE
    # Use the cache for file status to speed up large monorepos
    fsmonitor = true
    # Speed up index updates for untracked files
    untrackedCache = true

    # LINE ENDINGS & ENCODING
    # Force LF on commit
    autocrlf = input
    # Display CJK characters correctly in status/log output (do not escape)
    quotePath = false
    # Fix macOS unicode normalization issues (NFD vs NFC)
    precomposeunicode = true

    # EDITOR
    # External editor config (Force yourself to write good commit messages)
    editor = vim

[commit]
    # GPG sign commits by default ensures provenance
    gpgSign = true

    # Help formulate structured commit messages. Reminds you what files are actually changing.
    verbose = true

[tag]
    # GPG sign commits by default ensures provenance
    gpgSign = true

[column]
    # Display branches and lists in columns (like 'ls')
    ui = auto

[branch]
    # Sort branches by most recent commit date first. Saves time finding active context.
    sort = -committerdate

[diff]
    # LOGIC AWARENESS
    # Use Histogram algorithm. It is far superior to Myers for code logic.
    algorithm = histogram
    # Detect moved lines effectively to reduce diff noise
    colorMoved = default
    colorMovedWS = allow-indentation-change
    # Detect copies as well as renames for better history tracking
    renames = copies

    # Better diff header context
    tool = vimdiff

[merge]
    # Show common ancestor in conflicts (3-way diff)
    # CRITICAL for understanding the "why" behind a conflict
    conflictstyle = zdiff3

[pull]
    # LINEAR HISTORY ENFORCEMENT
    # Always rebase on pull. Never create merge bubbles for simple updates.
    rebase = true

[fetch]
    # CLEANUP & SPEED
    # Clean up stale remote-tracking branches
    prune = true
    pruneTags = true
    # Auto-detect CPU cores for parallel fetching
    parallel = 0

[push]
    # SAFETY & CONVENIENCE
    # Stricter safety. Only push if the upstream tracking branch matches.
    default = simple
    # Automatically setup remote tracking branch on first push (Git 2.37+)
    autoSetupRemote = true
    # Push tags automatically if they are related to the commits being pushed
    followTags = true

[rebase]
    # WORKFLOW OPTIMIZATION
    # Automatically stash dirty index before rebase and pop after
    autostash = true
    # Automatically handle fixup and squash commits during interactive rebase. Essential for atomic commit workflows.
    autosquash = true

[rerere]
    # REUSE RECORDED RESOLUTION
    # Automatically resolves conflicts you have resolved before.
    enabled = true

[help]
    # Auto-execute typos after 1 second (e.g., 'git sttaus' -> 'git status')
    autocorrect = 10

[alias]
    # --- Efficiency Shortcuts ---

    # Status: Short format with branch info
    s = status -sb

    # Switch & Restore (Deprecated checkout)
    sw = switch
    rs = restore

    # Cleanup Branch: Deletes all branches merged into current HEAD (or specified branch)
    # Excludes main, master, and the current checked-out branch.
    bclean = "!f() { git branch --merged ${1-HEAD} | grep -vE 'main|master|\\*' | xargs -r git branch -d; }; f"

    # --- Log Visualization ---

    # Minimal graph
    lg = log --oneline --graph --pretty=format:'%C(red)%h%Creset %C(bold cyan)<%an>%Creset -%C(bold magenta)%d%Creset %s %C(yellow)(%ar)%Creset'

    # Full history visualization with Commit Date
    lga = log --graph --abbrev-commit --decorate --all --date=format:'%Y-%m-%d %H:%M' --pretty=format:'%C(red)%h%Creset %C(green)%ad%Creset %C(yellow)(%ar)%Creset%C(bold magenta)%d%Creset %C(bold cyan)<%an>%Creset%n          %s'

    # --- Diff & Staging ---

    # Add interactively (Patch mode)
    ap = add -p

    # Commit with verbose output (shows diff in editor)
    ci = commit -v

    # Diff currently staged files
    ds = diff --staged

    # Diff excluding whitespace changes
    dw = diff -w

    # --- Rebase & Sync ---

    # Rebase interactive on last N commits
    ri = rebase -i

    # Continue rebase after conflict resolution
    rc = rebase --continue

    # Abort rebase
    ra = rebase --abort

    # Update: Pull with rebase
    up = pull --rebase

    # Safe force push (Protection against overwriting others work)
    pf = push --force-with-lease

    # --- Maintenance ---

    # Verify object database integrity (Check for corruption)
    verify = fsck --full --strict

# --- Conditional Includes ---
# This is a modern way to manage multiple work/personal identities.
#
# Usage:
# 1. Create a `~/.config/git/work.ini` file to store only company user information.
#    [user]
#        name = Company Foo
#        email = foo@company.com
#        signingkey = BBBBBBBBBBBBBBB
#
# 2. In the following settings, change `~/workspace/` to the directory path where you store your company projects.
#    Git will automatically load and overwrite the corresponding user settings when entering the directory.

[includeIf "gitdir:~/workspace/"]
    path = ~/.config/git/work.ini
